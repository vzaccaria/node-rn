#!/usr/bin/env node
// Generated by LiveScript 1.3.1
(function(){
  var docopt, _, fs, path, moment, _s, v, table, shelljs, bb, doc, patterns, getOption, o, go, keyword, use, save, ext, verb, fin, normal, verbose, targetProp, files, from, tto, dateExp, replaceSequenceAndDate, computeDestDir, replacePatterns, unwrapInfo, computeFinalName, move, final, f;
  docopt = require('docopt').docopt;
  _ = require('lodash');
  fs = require('fs');
  path = require('path');
  moment = require('moment');
  _s = require('underscore.string');
  v = require('verbal-expressions');
  table = require('easy-table');
  shelljs = require('shelljs');
  bb = require('bluebird');
  shelljs = bb.promisifyAll(shelljs);
  doc = shelljs.cat(__dirname + "/docs/usage.md");
  patterns = {};
  if (fs.existsSync(process.env.HOME + "/.rnc")) {
    patterns = JSON.parse(fs.readFileSync(process.env.HOME + "/.rnc", "utf-8"));
  }
  if (fs.existsSync(__dirname + "/.rnc")) {
    _.extend(patterns, JSON.parse(fs.readFileSync(__dirname + "/.rnc", "utf-8")));
  }
  getOption = function(a, b, def, o){
    if (!o[a] && !o[b]) {
      return def;
    } else {
      return o[b];
    }
  };
  o = docopt(doc);
  go = getOption('-g', '--go', false, o);
  keyword = getOption('-k', '--key', 'keyword', o);
  use = getOption('-u', '--use', '', o);
  save = getOption('-s', '--save', '', o);
  ext = getOption('-x', '--ext', false, o);
  verb = getOption('-v', '--verbose', false, o);
  fin = getOption('-f', '--finally', '', o);
  normal = console.log;
  verbose = function(){};
  if (verb) {
    verbose = console.log;
  }
  targetProp = (function(){
    switch (false) {
    case !!ext:
      return 'basenameNoext';
    default:
      return 'basename';
    }
  }());
  files = o["FILES"];
  from = o["FROM"];
  tto = o["TO"];
  if (use !== '') {
    if (patterns[use] != null) {
      from = patterns[use].from;
      tto = patterns[use].to;
    } else {
      console.log("Sorry, pattern " + use + " does not exist");
    }
  }
  dateExp = v().find("$D").then("{").beginCapture().anythingBut("}").endCapture().then("}");
  replaceSequenceAndDate = function(final){
    var k, v;
    for (k in final) {
      v = final[k];
      v.newName = v.newName.replace(/\$(0*)N/, fn$);
      v.newName = v.newName.replace(dateExp, fn1$);
      v.newName = v.newName.replace(/\$K/, fn2$);
      v.newName = v.newName.replace(/\$E/, fn3$);
    }
    return final;
    function fn$(s, sub){
      return _s.pad(k, sub.length, "0");
    }
    function fn1$(s, sub){
      return moment(fs.statSync(v.original).ctime).format(sub);
    }
    function fn2$(){
      return keyword;
    }
    function fn3$(){
      return v.ext.slice(1);
    }
  };
  computeDestDir = function(final){
    var i$, len$, f;
    for (i$ = 0, len$ = final.length; i$ < len$; ++i$) {
      f = final[i$];
      f.finalName = f.dirname + "/" + f.newName;
      if (!fs.existsSync(path.dirname(f.finalName))) {
        f.create = path.dirname(f.finalName);
      }
    }
    return final;
  };
  replacePatterns = function(final, from, tto){
    var reFrom;
    if (from == null) {
      from = '*';
    } else {
      from = from.replace(/\*/, "(.*)");
      tto = tto.replace(/\*/, "$1");
    }
    reFrom = new RegExp(from);
    final = _.filter(final, function(it){
      return reFrom.exec(it[targetProp]);
    });
    final = final.map(function(it){
      return _.extend(it, {
        newName: it[targetProp].replace(reFrom, tto)
      });
    });
    return final;
  };
  unwrapInfo = function(files){
    return _.map(files, function(it){
      it = path.normalize(it);
      return {
        original: it,
        dirname: path.dirname(it),
        ext: path.extname(it),
        basename: path.basename(it),
        basenameNoext: path.basename(it, path.extname(it))
      };
    });
  };
  computeFinalName = function(files){
    return _.map(files, function(f){
      var finalNameLong, finalNameRelative, createRelative;
      if (fin !== '') {
        f.newName = _s[fin](f.newName);
      }
      finalNameLong = (function(){
        switch (false) {
        case !ext:
          return f.dirname + "/" + f.newName;
        default:
          return f.dirname + "/" + f.newName + f.ext;
        }
      }());
      finalNameRelative = path.relative(path.dirname(f.original), finalNameLong);
      _.extend(f, {
        finalNameLong: finalNameLong,
        finalNameRelative: finalNameRelative
      });
      if (f.create != null) {
        createRelative = path.relative(path.dirname(f.original), f.create);
        _.extend(f, {
          createRelative: createRelative
        });
      }
      return f;
    });
  };
  move = function(f){
    var cmd;
    if (f.create != null) {
      normal("Create " + f.createRelative);
      verbose("mkdir -p " + f.create);
      if (go) {
        shelljs.mkdir('-p', f.create);
      }
    }
    normal("From: " + f.basename + " to " + f.finalNameRelative);
    cmd = "mv " + f.original + " " + f.finalNameLong;
    verbose(cmd);
    if (go) {
      return shelljs.execAsync(cmd);
    }
  };
  if (o['-l'] || o['--list']) {
    console.log("Available patterns");
    console.log("");
    console.log(table.printArray(_.toArray(patterns)));
  } else {
    final = unwrapInfo(files);
    final = replacePatterns(final, from, tto);
    final = replaceSequenceAndDate(final);
    final = computeDestDir(final);
    final = computeFinalName(final);
    bb.all((function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = final).length; i$ < len$; ++i$) {
        f = ref$[i$];
        results$.push(move(f));
      }
      return results$;
    }())).caught(function(){
      return console.log("errors found.");
    });
  }
}).call(this);
